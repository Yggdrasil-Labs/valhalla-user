name: Create Tag

on:
  # 监听 release-please 工作流的完成
  workflow_run:
    workflows: ["Release Please"]
    types:
      - completed
    branches:
      - main

permissions:
  contents: write

jobs:
  check-release-pr-merged:
    runs-on: ubuntu-latest
    if: github.event.workflow_run.conclusion == 'success'
    permissions:
      contents: read
      pull-requests: read
    outputs:
      is_release_pr: ${{ steps.check.outputs.is_release_pr }}
      merge_commit_sha: ${{ steps.check.outputs.merge_commit_sha }}
    steps:
      - name: Check if release PR was merged
        id: check
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // 获取触发此工作流的 release-please 工作流运行信息
            const workflowRun = context.payload.workflow_run;
            console.log(`Release Please workflow run: ${workflowRun.id}`);
            console.log(`Conclusion: ${workflowRun.conclusion}`);
            console.log(`Event: ${workflowRun.event}`);
            console.log(`Head branch: ${workflowRun.head_branch}`);
            
            // 获取最近的合并到 main 的 PR（最近 10 个）
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'closed',
              base: 'main',
              sort: 'updated',
              direction: 'desc',
              per_page: 10
            });
            
            // 查找最近合并的 release PR（在最近 5 分钟内合并的）
            const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000);
            const releasePR = prs.find(pr => {
              if (!pr.merged_at) return false;
              
              const mergedAt = new Date(pr.merged_at);
              const isRecent = mergedAt > fiveMinutesAgo;
              // 支持两种分支格式：
              // 1. simple release type: release-please--branches--main
              // 2. java release type: release-please--branches--main--components--*
              const isReleasePR = pr.head.ref.startsWith('release-please--branches--main') ||
                                pr.title.match(/chore\(main\): release/) ||
                                pr.title.includes('release');
              
              return isRecent && isReleasePR;
            });
            
            if (releasePR) {
              console.log(`✓ Found recently merged release PR: #${releasePR.number}`);
              console.log(`  Title: ${releasePR.title}`);
              console.log(`  Head ref: ${releasePR.head.ref}`);
              console.log(`  Merged at: ${releasePR.merged_at}`);
              console.log(`  Merge commit SHA: ${releasePR.merge_commit_sha}`);
              
              core.setOutput('is_release_pr', 'true');
              core.setOutput('merge_commit_sha', releasePR.merge_commit_sha || '');
            } else {
              console.log('ℹ️  No recently merged release PR found');
              console.log('   This workflow will be skipped');
              core.setOutput('is_release_pr', 'false');
              core.setOutput('merge_commit_sha', '');
            }

  create-and-push-tag:
    runs-on: ubuntu-latest
    needs: [check-release-pr-merged]
    if: needs.check-release-pr-merged.outputs.is_release_pr == 'true'
    permissions:
      contents: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          # 使用 RELEASE_TOKEN 进行 checkout，确保后续推送使用相同的 token
          token: ${{ secrets.RELEASE_TOKEN || secrets.GITHUB_TOKEN }}
          # checkout 到合并后的 commit（优先使用 merge_commit_sha，否则使用 main 分支）
          ref: ${{ needs.check-release-pr-merged.outputs.merge_commit_sha || 'main' }}

      - name: Extract version from manifest
        id: get_version
        run: |
          echo "=== Extracting Version ==="
          echo "Current commit SHA: $(git rev-parse HEAD)"
          echo "Current branch: $(git branch --show-current)"
          
          # 优先从 .release-please-manifest.json 中提取版本号（Release Please 的权威版本源）
          if [ -f ".github/.release-please-manifest.json" ]; then
            echo "Manifest file exists, reading..."
            cat .github/.release-please-manifest.json
            VERSION=$(jq -r '.["."]' .github/.release-please-manifest.json 2>/dev/null || echo "")
            if [ -n "$VERSION" ] && [ "$VERSION" != "null" ]; then
              echo "✓ Extracted version from manifest: $VERSION"
            else
              echo "⚠ Manifest exists but version is empty or null: '$VERSION'"
            fi
          else
            echo "⚠ Manifest file not found at .github/.release-please-manifest.json"
          fi
          
          # 如果从 manifest 获取失败，尝试从 CHANGELOG.md 中提取最新版本
          if [ -z "$VERSION" ] || [ "$VERSION" == "null" ]; then
            if [ -f "CHANGELOG.md" ]; then
              # 从 CHANGELOG 中提取第一个版本号（格式：## [1.1.0] 或 ## 1.1.0）
              VERSION=$(grep -m 1 -E '^## \[?[0-9]+\.[0-9]+\.[0-9]+\]?' CHANGELOG.md | sed -E 's/^## \[?([0-9]+\.[0-9]+\.[0-9]+)\]?.*/\1/' | head -1)
              if [ -n "$VERSION" ]; then
                echo "Extracted version from CHANGELOG: $VERSION"
              fi
            fi
          fi
          
          # 如果还是失败，回退到从 pom.xml 中提取（兼容旧版本）
          if [ -z "$VERSION" ] || [ "$VERSION" == "null" ]; then
            if [ -f "pom.xml" ]; then
              # 提取 <revision> 标签中的版本号（使用 sed，更兼容）
              VERSION=$(sed -n 's/.*<revision>\([^<]*\)<\/revision>.*/\1/p' pom.xml | head -1)
              if [ -z "$VERSION" ]; then
                # 如果没有 revision，尝试提取 <version>
                VERSION=$(sed -n 's/.*<version>\([^<]*\)<\/version>.*/\1/p' pom.xml | head -1)
              fi
              if [ -n "$VERSION" ]; then
                echo "Extracted version from pom.xml: $VERSION"
                # 移除 -SNAPSHOT 后缀（如果有）
                VERSION=${VERSION%-SNAPSHOT}
              fi
            fi
          fi
          
          if [ -z "$VERSION" ] || [ "$VERSION" == "null" ]; then
            echo "Error: Could not extract version from manifest, CHANGELOG, or pom.xml"
            echo "Manifest content:"
            cat .github/.release-please-manifest.json 2>/dev/null || echo "Manifest not found"
            echo "CHANGELOG first 10 lines:"
            head -10 CHANGELOG.md 2>/dev/null || echo "CHANGELOG not found"
            exit 1
          fi
          
          # 移除 -SNAPSHOT 后缀（如果有，虽然 manifest 中通常不会有）
          VERSION=${VERSION%-SNAPSHOT}
          
          # 生成 tag 名称（确保以 v 开头）
          if [[ "$VERSION" =~ ^v ]]; then
            TAG_NAME="$VERSION"
          else
            TAG_NAME="v$VERSION"
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "Final version: $VERSION"
          echo "Final tag name: $TAG_NAME"

      - name: Create and push tag
        env:
          TAG_NAME: ${{ steps.get_version.outputs.tag_name }}
          VERSION: ${{ steps.get_version.outputs.version }}
          # 使用 RELEASE_TOKEN (PAT) 来推送 tag，这样能自动触发 release 工作流
          RELEASE_TOKEN: ${{ secrets.RELEASE_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          echo "=== Creating Tag for Release ==="
          echo "Version: $VERSION"
          echo "Tag name: $TAG_NAME"
          echo "================================="
          
          if [ -z "$TAG_NAME" ] || [ -z "$VERSION" ]; then
            echo "Error: TAG_NAME or VERSION is empty"
            echo "TAG_NAME: $TAG_NAME"
            echo "VERSION: $VERSION"
            exit 1
          fi
          
          # 确保 tag 名称以 'v' 开头
          if [[ ! "$TAG_NAME" =~ ^v ]]; then
            TAG_NAME="v$TAG_NAME"
            echo "Adjusted tag name to: $TAG_NAME"
          fi
          
          # 获取当前 commit SHA
          COMMIT_SHA=$(git rev-parse HEAD)
          echo "Current commit SHA: $COMMIT_SHA"
          
          # 检查 tag 是否已存在
          if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
            EXISTING_SHA=$(git rev-parse "$TAG_NAME")
            if [ "$EXISTING_SHA" == "$COMMIT_SHA" ]; then
              echo "✓ Tag $TAG_NAME already exists and points to the same commit, skipping creation"
            else
              echo "⚠ Warning: Tag $TAG_NAME exists but points to different commit"
              echo "  Existing: $EXISTING_SHA"
              echo "  Current:  $COMMIT_SHA"
              exit 1
            fi
          else
            # 创建 tag（指向当前 HEAD，即合并后的 commit）
            echo "Creating annotated tag: $TAG_NAME"
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git tag -a "$TAG_NAME" -m "Release $VERSION"
            
            # 使用 RELEASE_TOKEN (PAT) 推送 tag，这样能自动触发 release 工作流
            # 如果 RELEASE_TOKEN 不存在，回退到 GITHUB_TOKEN（但不会触发工作流）
            if [ -n "$RELEASE_TOKEN" ] && [ "$RELEASE_TOKEN" != "" ]; then
              echo "Using RELEASE_TOKEN to push tag (will trigger Release workflow automatically)"
              # 配置 git 使用 PAT 进行推送
              # 注意：PAT 需要使用 'x-access-token' 作为用户名，而不是实际的 GitHub 用户名
              git remote set-url origin https://x-access-token:${RELEASE_TOKEN}@github.com/${GITHUB_REPOSITORY}.git
              
              # 验证 remote URL 配置
              echo "Current remote URL:"
              git remote get-url origin | sed 's/\/\/.*@/\/\/***@/'  # 隐藏 token
              
              # 推送 tag
              echo "Pushing tag $TAG_NAME..."
              if git push origin "$TAG_NAME"; then
                echo "✓ Successfully created and pushed tag: $TAG_NAME using RELEASE_TOKEN"
                echo "✓ This should trigger the Release workflow automatically"
              else
                echo "❌ Failed to push tag"
                exit 1
              fi
            else
              echo "⚠️  RELEASE_TOKEN not found, using GITHUB_TOKEN (will NOT trigger Release workflow)"
              echo "   Please configure RELEASE_TOKEN secret to enable automatic workflow triggering"
              git push origin "$TAG_NAME"
              echo "✓ Tag pushed, but Release workflow will NOT be triggered automatically"
              echo "   You need to manually trigger it or configure RELEASE_TOKEN secret"
            fi
          fi

